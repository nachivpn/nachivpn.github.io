---
layout: default
---

I'm an aspiring computer scientist who will be pursuing a PhD at Chalmers University starting September 2018.

## Interests

Technology and programming excites me, but no more than the underlying theory. Currently, I'm experimenting with my interests in programming language theory and formal logic, with an application in concurrent and distributed systems. Functional programming and type systems for distributed programming are of particular interest to me.

## Recent work

* [Typing the Wild in Erlang](ew18.pdf), Erlang Workshop at ICFP 2018
* [Towards Adding Variety to Simplicity](variety.pdf), ISoLA 2018

## What am I upto?

* Organizing talks at [Papers We Love, Gothenburg](http://paperswelove.org/chapter/gothenburg/)

## Some things I've done in the past
* Masters in Computer Science (Algorithms, Logic and Languages) at Chalmers University, Sweden
* Summer student at CERN, worked on [Molr](https://github.com/nachivpn/molr-core) & [FADE](https://webfest.web.cern.ch/content/fade-framework-distributed-execution)
* Distributed systems at [Acrodelon R&D](http://acrodelon.com)
* Backend development/consultant at/for a bunch of companies
* Bachelors in Computer Science & Engineering at National Institute of Technology, Calicut
 
## Social

* [Blog](http://blog.nachivpn.me/)
* [Github](https://github.com/nachivpn)
* [Twitter](https://twitter.com/nachivpn)
* [Goodreads](https://www.goodreads.com/user/show/45403127-nachi)

## Some (old) rant

Programming languages provide powerful abstractions to build software systems. Much success has been achieved in sequential computation - we have a plethora of high level programming languages which ensure we don't worry too much about memory management, run time safety and other similar "low level" problems. It is the age of distributed computation and we are still using tools designed for sequential computation. It appears that when building distributed systems, we spend most of our time solving concurrency and communication problems. It would be useful to have tools (say a programming language) to solve these problems internally and provide an effective abstraction to build distributed systems. This way, one can focus on the application logic instead of writing tedious communication protocols, synchronization algorithms etc. This is an interesting and active area of research in both the academia and the industry.
