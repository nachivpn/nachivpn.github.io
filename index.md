---
layout: default
---

I am an aspiring computer scientist doing Masters in Computer Science (Algorithms, Logic and Languages) at Chalmers University of Technology in Sweden.

## Interests

Technology and programming excites me, but no more than the underlying theory. Currently, I'm experimenting with my interests in programming language theory and formal logic with an application in concurrent and distributed systems. Functional programming and type systems for large scale distributed software seem like interesting areas of research.

## What am I upto?

* Working on a static type system for Erlang!
* Learning category theory by realizing the more familiar proof theory and type theory in it
* Teaching Assistant at Chalmers/Gothenburg University  
* Organizing talks at [Papers We Love, Gothenburg](http://paperswelove.org/chapter/gothenburg/)

## Some things I've done in the past
* Summer student at CERN, worked on [Molr](https://github.com/nachivpn/molr-core) & [FADE](https://webfest.web.cern.ch/content/fade-framework-distributed-execution)
* Project on theoretical foundations for reasoning about concurrent imperative programs using logic
* Distributed systems (and some AI) at [Acrodelon R&D](http://acrodelon.com)
* Backend development/consultant at/for a bunch of companies
* Project on designing a compiler construction laboratory ([SILCNITC](http://silcnitc.github.io/about.html))
 
## Social

* [Blog](http://blog.nachivpn.me/)
* [Github](https://github.com/nachivpn)
* [Twitter](https://twitter.com/nachivpn)
* [LinkedIn](https://www.linkedin.com/in/nachivpn)
* [Goodreads](https://www.goodreads.com/user/show/45403127-nachi)

## Miscellaneous

* [Mention on VentureBeat](http://venturebeat.com/2014/12/24/googles-no-captcha-recaptchas-may-not-be-as-bot-proof-as-we-thought)

## Some (old) rant

Programming languages provide powerful abstractions to build software systems. Much success has been achieved in sequential computation - we have a plethora of high level programming languages which ensure we don't worry too much about memory management, run time safety and other similar "low level" problems. It is the age of distributed computation and we are still using tools designed for sequential computation. It appears that when building distributed systems, we spend most of our time solving concurrency and communication problems. It would be useful to have tools (say a programming language) to solve these problems internally and provide an effective abstraction to build distributed systems. This way, one can focus on the application logic instead of writing tedious communication protocols, synchronization algorithms etc. This is an interesting and active area of research in both the academia and the industry.
